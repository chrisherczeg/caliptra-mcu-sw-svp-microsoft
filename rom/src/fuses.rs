// Licensed under the Apache-2.0 license

use core::fmt::Write;
use registers_generated::fuses::Fuses;
use registers_generated::otp_ctrl;
use registers_generated::{fuses, lc_ctrl};
use romtime::{HexBytes, HexWord, McuError, StaticRef};
use tock_registers::interfaces::{Readable, Writeable};

use crate::fatal_error;

// TODO: use the Lifecycle controller to read the Lifecycle state

const OTP_STATUS_ERROR_MASK: u32 = (1 << 22) - 1;
const OTP_CONSISTENCY_CHECK_PERIOD_MASK: u32 = 0x3ff_ffff;
const OTP_INTEGRITY_CHECK_PERIOD_MASK: u32 = 0x3ff_ffff;
const OTP_CHECK_TIMEOUT: u32 = 0x10_0000;

// TODO: fix the autogenerated offsets
// const LC_TOKENS_OFFSET: usize = fuses::SECRET_LC_TRANSITION_PARTITION_BYTE_OFFSET;
const LC_TOKENS_OFFSET: usize = 0x4a0;

/// Unhashed token, suitable for doing lifecycle transitions.
#[derive(Clone, Copy)]
pub struct LifecycleToken(pub [u8; 16]);

impl From<[u8; 16]> for LifecycleToken {
    fn from(value: [u8; 16]) -> Self {
        LifecycleToken(value)
    }
}

impl From<LifecycleToken> for [u8; 16] {
    fn from(value: LifecycleToken) -> Self {
        value.0
    }
}

/// Hashed token, suitable for burning into the OTP.
#[derive(Clone, Copy)]
pub struct LifecycleHashedToken(pub [u8; 16]);

impl From<[u8; 16]> for LifecycleHashedToken {
    fn from(value: [u8; 16]) -> Self {
        LifecycleHashedToken(value)
    }
}

impl From<LifecycleHashedToken> for [u8; 16] {
    fn from(value: LifecycleHashedToken) -> Self {
        value.0
    }
}

/// Hashed tokens to be burned into the OTP for lifecycle transitions.
#[allow(dead_code)]
pub struct LifecycleHashedTokens {
    pub test_unlock: [LifecycleHashedToken; 7],
    pub manuf: LifecycleHashedToken,
    pub manuf_to_prod: LifecycleHashedToken,
    pub prod_to_prod_end: LifecycleHashedToken,
    pub rma: LifecycleHashedToken,
}

#[derive(Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum LifecycleControllerState {
    Raw = 0,
    TestUnlocked0 = 1,
    TestLocked0 = 2,
    TestUnlocked1 = 3,
    TestLocked1 = 4,
    TestUnlocked2 = 5,
    TestLocked2 = 6,
    TestUnlocked3 = 7,
    TestLocked3 = 8,
    TestUnlocked4 = 9,
    TestLocked4 = 10,
    TestUnlocked5 = 11,
    TestLocked5 = 12,
    TestUnlocked6 = 13,
    TestLocked6 = 14,
    TestUnlocked7 = 15,
    Dev = 16,
    Prod = 17,
    ProdEnd = 18,
    Rma = 19,
    Scrap = 20,
}

impl From<LifecycleControllerState> for u8 {
    fn from(value: LifecycleControllerState) -> Self {
        match value {
            LifecycleControllerState::Raw => 0,
            LifecycleControllerState::TestUnlocked0 => 1,
            LifecycleControllerState::TestLocked0 => 2,
            LifecycleControllerState::TestUnlocked1 => 3,
            LifecycleControllerState::TestLocked1 => 4,
            LifecycleControllerState::TestUnlocked2 => 5,
            LifecycleControllerState::TestLocked2 => 6,
            LifecycleControllerState::TestUnlocked3 => 7,
            LifecycleControllerState::TestLocked3 => 8,
            LifecycleControllerState::TestUnlocked4 => 9,
            LifecycleControllerState::TestLocked4 => 10,
            LifecycleControllerState::TestUnlocked5 => 11,
            LifecycleControllerState::TestLocked5 => 12,
            LifecycleControllerState::TestUnlocked6 => 13,
            LifecycleControllerState::TestLocked6 => 14,
            LifecycleControllerState::TestUnlocked7 => 15,
            LifecycleControllerState::Dev => 16,
            LifecycleControllerState::Prod => 17,
            LifecycleControllerState::ProdEnd => 18,
            LifecycleControllerState::Rma => 19,
            LifecycleControllerState::Scrap => 20,
        }
    }
}

impl From<u8> for LifecycleControllerState {
    fn from(value: u8) -> Self {
        match value {
            1 => LifecycleControllerState::TestUnlocked0,
            2 => LifecycleControllerState::TestLocked0,
            3 => LifecycleControllerState::TestUnlocked1,
            4 => LifecycleControllerState::TestLocked1,
            5 => LifecycleControllerState::TestUnlocked2,
            6 => LifecycleControllerState::TestLocked2,
            7 => LifecycleControllerState::TestUnlocked3,
            8 => LifecycleControllerState::TestLocked3,
            9 => LifecycleControllerState::TestUnlocked4,
            10 => LifecycleControllerState::TestLocked4,
            11 => LifecycleControllerState::TestUnlocked5,
            12 => LifecycleControllerState::TestLocked5,
            13 => LifecycleControllerState::TestUnlocked6,
            14 => LifecycleControllerState::TestLocked6,
            15 => LifecycleControllerState::TestUnlocked7,
            16 => LifecycleControllerState::Dev,
            17 => LifecycleControllerState::Prod,
            18 => LifecycleControllerState::ProdEnd,
            19 => LifecycleControllerState::Rma,
            20 => LifecycleControllerState::Scrap,
            _ => LifecycleControllerState::Raw,
        }
    }
}

impl From<u32> for LifecycleControllerState {
    fn from(value: u32) -> Self {
        ((value & 0x1f) as u8).into()
    }
}

pub struct Lifecycle {
    registers: StaticRef<lc_ctrl::regs::LcCtrl>,
}

impl Lifecycle {
    pub const fn new(registers: StaticRef<lc_ctrl::regs::LcCtrl>) -> Self {
        Lifecycle { registers }
    }

    pub fn init(&self) -> Result<(), McuError> {
        romtime::println!("[mcu-lcc] Initializing Lifecycle controller...");
        while !self.registers.status.is_set(lc_ctrl::bits::Status::Ready) {}
        while !self
            .registers
            .status
            .is_set(lc_ctrl::bits::Status::Initialized)
        {}

        romtime::println!(
            "[mcu-lcc] Lifecycle state: {} (count {})",
            HexWord(self.registers.lc_state.get() & 0x1f),
            self.registers.lc_transition_cnt.get()
        );

        romtime::println!("Lifecycle controller initialization done");
        Ok(())
    }

    pub fn status(&self) -> u32 {
        self.registers.status.get()
    }

    fn calc_lc_state_mnemonic(state: LifecycleControllerState) -> u32 {
        let state = u8::from(state);
        let next_lc_state_5bit = (state & 0x1F) as u32;

        (next_lc_state_5bit << 25)
            | (next_lc_state_5bit << 20)
            | (next_lc_state_5bit << 15)
            | (next_lc_state_5bit << 10)
            | (next_lc_state_5bit << 5)
            | next_lc_state_5bit
    }

    pub fn transition(
        &self,
        state: LifecycleControllerState,
        token: &LifecycleToken,
    ) -> Result<(), McuError> {
        romtime::println!(
            "[mcu-rom-lcc] Transitioning Lifecycle state... to {}",
            u8::from(state)
        );
        let next_lc_state_mne = Self::calc_lc_state_mnemonic(state);
        let token = u128::from_le_bytes(token.0);

        const MULTI_TRUE: u32 = 0x96;

        // Step 1: Set Claim Transition Register
        while self.registers.claim_transition_if.get() != MULTI_TRUE {
            self.registers.claim_transition_if.set(MULTI_TRUE);
            let reg_value = self.registers.claim_transition_if.get();
            romtime::println!(
                "[mcu-rom-lcc] Claim Mutex Register: {} (should be {})",
                HexWord(reg_value),
                HexWord(MULTI_TRUE)
            );
        }
        romtime::println!("[mcu-rom-lcc] Mutex successfully acquired.");

        // Step 3: Set Target Lifecycle State
        romtime::println!(
            "[mcu-rom-lcc] Setting next lifecycle state: 0x{:02x}",
            next_lc_state_mne & 0x1f
        );
        self.registers.transition_target.set(next_lc_state_mne);

        // Step 4: Write Transition Tokens
        let token_31_0 = (token & 0xFFFF_FFFF) as u32;
        let token_63_32 = ((token >> 32) & 0xFFFF_FFFF) as u32;
        let token_95_64 = ((token >> 64) & 0xFFFF_FFFF) as u32;
        let token_127_96 = ((token >> 96) & 0xFFFF_FFFF) as u32;

        romtime::println!("[mcu-rom-lcc] Writing tokens: 0x{:08x}", token_31_0);
        self.registers.transition_token_0.set(token_31_0);
        romtime::println!("[mcu-rom-lcc] Writing tokens: 0x{:08x}", token_63_32);
        self.registers.transition_token_1.set(token_63_32);
        romtime::println!("[mcu-rom-lcc] Writing tokens: 0x{:08x}", token_95_64);
        self.registers.transition_token_2.set(token_95_64);
        romtime::println!("[mcu-rom-lcc] Writing tokens: 0x{:08x}", token_127_96);
        self.registers.transition_token_3.set(token_127_96);

        // Step 6: Trigger the Transition Command
        romtime::println!("[mcu-rom-lcc] Triggering transition command: 0x1",);
        self.registers.transition_cmd.set(1);

        // Step 7: Poll Status Register
        loop {
            let status = self.registers.status.extract();
            romtime::println!(
                "[mcu-rom-lcc] Polling status register: {}",
                HexWord(status.get())
            );

            if status.is_set(lc_ctrl::bits::Status::TransitionSuccessful) {
                romtime::println!("[mcu-rom-lcc] Transition successful.");
                break;
            }
            if status.is_set(lc_ctrl::bits::Status::TransitionError) {
                romtime::println!("[mcu-rom-lcc] Transition error detected.");
                fatal_error(10);
            }
            if status.is_set(lc_ctrl::bits::Status::TokenError) {
                romtime::println!("[mcu-rom-lcc] Token error detected.");
                fatal_error(10);
            }
            if status.is_set(lc_ctrl::bits::Status::OtpError) {
                romtime::println!("[mcu-rom-lcc] OTP error detected.");
                fatal_error(10);
            }
            if status.is_set(lc_ctrl::bits::Status::FlashRmaError) {
                romtime::println!("[mcu-rom-lcc] FLASH RMA error detected.");
                fatal_error(10);
            }
            if status.is_set(lc_ctrl::bits::Status::TransitionCountError) {
                romtime::println!("[mcu-rom-lcc] Transition count error detected.");
                fatal_error(10);
            }
            if status.is_set(lc_ctrl::bits::Status::StateError) {
                romtime::println!("[mcu-rom-lcc] State error detected.");
                fatal_error(10);
            }
            if status.is_set(lc_ctrl::bits::Status::BusIntegError) {
                romtime::println!("[mcu-rom-lcc] Bus integrity error detected.");
                fatal_error(10);
            }
            if status.is_set(lc_ctrl::bits::Status::OtpPartitionError) {
                romtime::println!("[mcu-rom-lcc] OTP partition error detected.");
                fatal_error(10);
            }
        }

        self.registers.claim_transition_if.set(0);

        romtime::println!("[mcu-rom-lcc] Lifecycle state transitioned");
        Ok(())
    }
}

pub struct Otp {
    enable_consistency_check: bool,
    enable_integrity_check: bool,
    registers: StaticRef<otp_ctrl::regs::OtpCtrl>,
}

impl Otp {
    pub const fn new(
        enable_consistency_check: bool,
        enable_integrity_check: bool,
        registers: StaticRef<otp_ctrl::regs::OtpCtrl>,
    ) -> Self {
        Otp {
            enable_consistency_check,
            enable_integrity_check,
            registers,
        }
    }

    pub fn volatile_lock(&self) {
        self.registers.vendor_pk_hash_volatile_lock.set(1);
    }

    pub fn init(&self) -> Result<(), McuError> {
        romtime::println!("[mcu-rom-otp] Initializing OTP controller...");
        if self.registers.otp_status.get() & OTP_STATUS_ERROR_MASK != 0 {
            romtime::println!(
                "[mcu-rom-otp] OTP error: {}",
                self.registers.otp_status.get()
            );
            return Err(McuError::FusesError);
        }

        // OTP DAI status should be idle
        if !self
            .registers
            .otp_status
            .is_set(otp_ctrl::bits::OtpStatus::DaiIdle)
        {
            romtime::println!("[mcu-rom-otp] OTP not idle");
            return Err(McuError::FusesError);
        }

        // Enable periodic background checks
        if self.enable_consistency_check {
            romtime::println!("[mcu-rom-otp] Enabling consistency check period");
            self.registers
                .consistency_check_period
                .set(OTP_CONSISTENCY_CHECK_PERIOD_MASK);
        }
        if self.enable_integrity_check {
            romtime::println!("mcu-rom-otp] Enabling integrity check period");
            self.registers
                .integrity_check_period
                .set(OTP_INTEGRITY_CHECK_PERIOD_MASK);
        }
        romtime::println!("mcu-rom-otp] Enabling check timeout");
        self.registers.check_timeout.set(OTP_CHECK_TIMEOUT);

        // Disable modifications to the background checks
        romtime::println!("[mcu-rom-otp] Disabling check modifications");
        self.registers
            .check_regwen
            .write(otp_ctrl::bits::CheckRegwen::Regwen::CLEAR);
        romtime::println!("[mcu-rom-otp] Done init");
        Ok(())
    }

    pub fn status(&self) -> u32 {
        self.registers.otp_status.get()
    }

    fn read_data(&self, addr: usize, len: usize, data: &mut [u8]) -> Result<(), McuError> {
        if data.len() < len || len % 4 != 0 {
            return Err(McuError::InvalidDataError);
        }
        for (i, chunk) in data[..len].chunks_exact_mut(4).enumerate() {
            let word = self.read_word(addr / 4 + i)?;
            let word_bytes = word.to_le_bytes();
            chunk.copy_from_slice(&word_bytes[..chunk.len()]);
        }
        Ok(())
    }

    /// Reads a word from the OTP controller.
    /// word_addr is in words
    pub fn read_word(&self, word_addr: usize) -> Result<u32, McuError> {
        // OTP DAI status should be idle
        while !self
            .registers
            .otp_status
            .is_set(otp_ctrl::bits::OtpStatus::DaiIdle)
        {}

        self.registers
            .direct_access_address
            .set((word_addr * 4) as u32);
        // trigger a read
        self.registers.direct_access_cmd.set(1);

        // wait for DAI to go back to idle
        while !self
            .registers
            .otp_status
            .is_set(otp_ctrl::bits::OtpStatus::DaiIdle)
        {}

        if let Some(err) = self.check_error() {
            romtime::println!("Error reading fuses: {}", HexWord(err));
            return Err(McuError::FusesError);
        }
        Ok(self.registers.dai_rdata_rf_direct_access_rdata_0.get())
    }

    /// Write a dword to the OTP controller.
    /// word_addr is in words
    pub fn write_dword(&self, dword_addr: usize, data: u64) -> Result<u32, McuError> {
        // OTP DAI status should be idle
        while !self
            .registers
            .otp_status
            .is_set(otp_ctrl::bits::OtpStatus::DaiIdle)
        {}

        // load the data
        romtime::println!("Write dword 0: {}", HexWord(data as u32));
        self.registers
            .dai_wdata_rf_direct_access_wdata_0
            .set((data) as u32);
        romtime::println!("Write dword 1: {}", HexWord((data >> 32) as u32));
        self.registers
            .dai_wdata_rf_direct_access_wdata_1
            .set((data >> 32) as u32);

        self.registers
            .direct_access_address
            .set((dword_addr * 8) as u32);
        // trigger a write
        self.registers.direct_access_cmd.set(2);

        // wait for DAI to go back to idle
        while !self
            .registers
            .otp_status
            .is_set(otp_ctrl::bits::OtpStatus::DaiIdle)
        {}

        if let Some(err) = self.check_error() {
            romtime::println!("Error writing fuses: {}", HexWord(err));
            self.print_errors();
            return Err(McuError::FusesError);
        }
        Ok(self.registers.dai_rdata_rf_direct_access_rdata_0.get())
    }

    /// Write a word to the OTP controller.
    /// word_addr is in words
    pub fn write_word(&self, word_addr: usize, data: u32) -> Result<u32, McuError> {
        // OTP DAI status should be idle
        while !self
            .registers
            .otp_status
            .is_set(otp_ctrl::bits::OtpStatus::DaiIdle)
        {}

        // load the data
        self.registers.dai_wdata_rf_direct_access_wdata_0.set(data);

        self.registers
            .direct_access_address
            .set((word_addr * 4) as u32);
        // trigger a write
        self.registers.direct_access_cmd.set(2);

        // wait for DAI to go back to idle
        while !self
            .registers
            .otp_status
            .is_set(otp_ctrl::bits::OtpStatus::DaiIdle)
        {}

        if let Some(err) = self.check_error() {
            romtime::println!("[mcu-rom] Error writing fuses: {}", HexWord(err));
            self.print_errors();
            return Err(McuError::FusesError);
        }
        Ok(self.registers.dai_rdata_rf_direct_access_rdata_0.get())
    }

    /// Finalize a partition
    /// word_addr is in words
    pub fn finalize_digest(&self, partition_base_addr: usize) -> Result<(), McuError> {
        romtime::println!(
            "[mcu-rom] Finalizing partition at base address: {}",
            HexWord(partition_base_addr as u32)
        );
        // OTP DAI status should be idle
        while !self
            .registers
            .otp_status
            .is_set(otp_ctrl::bits::OtpStatus::DaiIdle)
        {}

        // Write base address of partition
        self.registers
            .direct_access_address
            .set(partition_base_addr as u32);
        // trigger a digest
        self.registers.direct_access_cmd.set(4);

        // wait for DAI to go back to idle
        while !self
            .registers
            .otp_status
            .is_set(otp_ctrl::bits::OtpStatus::DaiIdle)
        {}

        if let Some(err) = self.check_error() {
            romtime::println!("[mcu-rom] Error writing digest: {}", HexWord(err));
            self.print_errors();
            return Err(McuError::FusesError);
        }
        Ok(())
    }

    pub fn print_errors(&self) {
        for i in 0..18 {
            let err_code = match i {
                0 => self.registers.err_code_rf_err_code_0.get(),
                1 => self.registers.err_code_rf_err_code_1.get(),
                2 => self.registers.err_code_rf_err_code_2.get(),
                3 => self.registers.err_code_rf_err_code_3.get(),
                4 => self.registers.err_code_rf_err_code_4.get(),
                5 => self.registers.err_code_rf_err_code_5.get(),
                6 => self.registers.err_code_rf_err_code_6.get(),
                7 => self.registers.err_code_rf_err_code_7.get(),
                8 => self.registers.err_code_rf_err_code_8.get(),
                9 => self.registers.err_code_rf_err_code_9.get(),
                10 => self.registers.err_code_rf_err_code_10.get(),
                11 => self.registers.err_code_rf_err_code_11.get(),
                12 => self.registers.err_code_rf_err_code_12.get(),
                13 => self.registers.err_code_rf_err_code_13.get(),
                14 => self.registers.err_code_rf_err_code_14.get(),
                15 => self.registers.err_code_rf_err_code_15.get(),
                16 => self.registers.err_code_rf_err_code_16.get(),
                17 => self.registers.err_code_rf_err_code_17.get(),
                _ => 0,
            };
            if err_code != 0 {
                romtime::println!("[mcu] OTP error code {}: {}", i, err_code);
            }
        }
    }

    pub fn check_error(&self) -> Option<u32> {
        let status = self.registers.otp_status.get() & OTP_STATUS_ERROR_MASK;
        if status == 0 {
            None
        } else {
            Some(status)
        }
    }

    pub fn read_fuses(&self) -> Result<Fuses, McuError> {
        let mut fuses = Fuses::default();
        self.read_data(
            fuses::SW_TEST_UNLOCK_PARTITION_BYTE_OFFSET,
            fuses::SW_TEST_UNLOCK_PARTITION_BYTE_SIZE,
            &mut fuses.sw_test_unlock_partition,
        )?;
        self.read_data(
            fuses::SECRET_MANUF_PARTITION_BYTE_OFFSET,
            fuses::SECRET_MANUF_PARTITION_BYTE_SIZE,
            &mut fuses.secret_manuf_partition,
        )?;
        self.read_data(
            fuses::SECRET_PROD_PARTITION_0_BYTE_OFFSET,
            fuses::SECRET_PROD_PARTITION_0_BYTE_SIZE,
            &mut fuses.secret_prod_partition_0,
        )?;
        self.read_data(
            fuses::SECRET_PROD_PARTITION_1_BYTE_OFFSET,
            fuses::SECRET_PROD_PARTITION_1_BYTE_SIZE,
            &mut fuses.secret_prod_partition_1,
        )?;
        self.read_data(
            fuses::SECRET_PROD_PARTITION_2_BYTE_OFFSET,
            fuses::SECRET_PROD_PARTITION_2_BYTE_SIZE,
            &mut fuses.secret_prod_partition_2,
        )?;
        self.read_data(
            fuses::SECRET_PROD_PARTITION_3_BYTE_OFFSET,
            fuses::SECRET_PROD_PARTITION_3_BYTE_SIZE,
            &mut fuses.secret_prod_partition_3,
        )?;
        self.read_data(
            fuses::SW_MANUF_PARTITION_BYTE_OFFSET,
            fuses::SW_MANUF_PARTITION_BYTE_SIZE,
            &mut fuses.sw_manuf_partition,
        )?;
        self.read_data(
            fuses::SECRET_LC_TRANSITION_PARTITION_BYTE_OFFSET,
            fuses::SECRET_LC_TRANSITION_PARTITION_BYTE_SIZE,
            &mut fuses.secret_lc_transition_partition,
        )?;
        self.read_data(
            fuses::SVN_PARTITION_BYTE_OFFSET,
            fuses::SVN_PARTITION_BYTE_SIZE,
            &mut fuses.svn_partition,
        )?;
        self.read_data(
            fuses::VENDOR_TEST_PARTITION_BYTE_OFFSET,
            fuses::VENDOR_TEST_PARTITION_BYTE_SIZE,
            &mut fuses.vendor_test_partition,
        )?;
        self.read_data(
            fuses::VENDOR_HASHES_MANUF_PARTITION_BYTE_OFFSET,
            fuses::VENDOR_HASHES_MANUF_PARTITION_BYTE_SIZE,
            &mut fuses.vendor_hashes_manuf_partition,
        )?;
        self.read_data(
            fuses::VENDOR_HASHES_PROD_PARTITION_BYTE_OFFSET,
            fuses::VENDOR_HASHES_PROD_PARTITION_BYTE_SIZE,
            &mut fuses.vendor_hashes_prod_partition,
        )?;
        self.read_data(
            fuses::VENDOR_REVOCATIONS_PROD_PARTITION_BYTE_OFFSET,
            fuses::VENDOR_REVOCATIONS_PROD_PARTITION_BYTE_SIZE,
            &mut fuses.vendor_revocations_prod_partition,
        )?;
        self.read_data(
            fuses::VENDOR_SECRET_PROD_PARTITION_BYTE_OFFSET,
            fuses::VENDOR_SECRET_PROD_PARTITION_BYTE_SIZE,
            &mut fuses.vendor_secret_prod_partition,
        )?;
        self.read_data(
            fuses::VENDOR_NON_SECRET_PROD_PARTITION_BYTE_OFFSET,
            fuses::VENDOR_NON_SECRET_PROD_PARTITION_BYTE_SIZE,
            &mut fuses.vendor_non_secret_prod_partition,
        )?;
        Ok(fuses)
    }

    pub(crate) fn burn_lifecycle_tokens(
        &self,
        tokens: &LifecycleHashedTokens,
    ) -> Result<(), McuError> {
        for (i, tokeni) in tokens.test_unlock.iter().enumerate() {
            romtime::println!(
                "[mcu-rom-otp] Burning test_unlock{} token: {}",
                i,
                HexBytes(&tokeni.0)
            );
            self.burn_lifecycle_token(LC_TOKENS_OFFSET + i * 16, tokeni)?;
        }

        romtime::println!(
            "[mcu-rom-otp] Burning manuf token: {}",
            HexBytes(&tokens.manuf.0)
        );
        self.burn_lifecycle_token(LC_TOKENS_OFFSET + 7 * 16, &tokens.manuf)?;

        romtime::println!(
            "[mcu-rom-otp] Burning manuf_to_prod token: {}",
            HexBytes(&tokens.manuf_to_prod.0)
        );
        self.burn_lifecycle_token(LC_TOKENS_OFFSET + 8 * 16, &tokens.manuf_to_prod)?;

        romtime::println!(
            "[mcu-rom-otp] Burning prod_to_prod_end token: {}",
            HexBytes(&tokens.prod_to_prod_end.0)
        );
        self.burn_lifecycle_token(LC_TOKENS_OFFSET + 9 * 16, &tokens.prod_to_prod_end)?;

        romtime::println!(
            "[mcu-rom-otp] Burning rma token: {}",
            HexBytes(&tokens.rma.0)
        );
        self.burn_lifecycle_token(LC_TOKENS_OFFSET + 10 * 16, &tokens.rma)?;

        romtime::println!("[mcu-rom] Finalizing digest");
        self.finalize_digest(LC_TOKENS_OFFSET)?;
        Ok(())
    }

    fn burn_lifecycle_token(
        &self,
        addr: usize,
        token: &LifecycleHashedToken,
    ) -> Result<(), McuError> {
        let dword = u64::from_le_bytes(token.0[..8].try_into().unwrap());
        self.write_dword(addr / 8, dword)?;

        let dword = u64::from_le_bytes(token.0[8..16].try_into().unwrap());
        self.write_dword((addr + 8) / 8, dword)?;
        Ok(())
    }
}
